# 리팩터링 원칙

## 2.1 리팩터링 정의

> 리팩터링
> [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
> [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다."라고 한다면, 십중팔구 리팩터링한 것이 아니다.

리팩터링의 단계를 잘게 나눔으로써 우리는 디벙기하는 데 시간을 뺏기지 않을 수 있습니다.

리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것입니다. 이 과정에서 콜 스택이 달라지면서 성능이 변할 수도 있습니다. 반면, 성능 최적화는 오로지 속도 개선에만 신경쓰면서 코드를 다루는 것이 복잡해 질 수 있습니다.

## 2.2 두개의 모자

켄트 벡은 소프트웨어를 개발할 때의 목적을 두 개의 모자에 비유했습니다. `기능 추가` 모자를 썻을 때는 새 기능을 추가하고 테스트 코드를 추가하는지 확인하며 진척도를 측정합니다. 반면 `리팩토링` 모자를 썼을 때는 기능 추가 없이 오로지 코드 재구성에만 전념합니다. 이 때, 새로운 기능 추가 시 테스트 케이스를 놓쳤거나, 인터페이스가 변경하는 경우가 아니라면 테스트를 건드려서는 안 됩니다.

## 2.3 리팩터링하는 이유

### 리팩터링하면 소프트웨어 설계가 좋아진다

코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워진다. 규칙적인 리팩터링은 코드 구조를 지탱해줍니다.

코드가 길수록 실수 없이 수정하기 어려워집니다. 이해해야 할 코드량이 늘어나고, 비슷한 일을 하는 코드가 산재해있으면 시스템이 예상대로 작동하지 않을 수 있습니다.

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

내 소스 코드를 읽는 것은 컴퓨터뿐만이 아닙니다. 언젠가 다른 사람이, 내가 다시 코드를 읽었을 때 의도를 쉽게 파악하고 빠르게 목적을 달성할 수 있어야 합니다.

### 리팩터링하면 버그를 쉽게 찾을 수 있다.

코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 합니다. 프로그램의 구조를 명확히 다듬으면 '이럴 것이다'라고 가정하던 점들이 드러나며, 버그를 지나치고 싶어도 지나칠 수 없을 정도로 명확해집니다.

### 리팩터링면 프로그래밍 속도를 높일 수 있다.

내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 됩니다.

## 2.4 언제 리팩터링해야 할까?

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전입니다. 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 부분을 찾습니다. 

버그를 잡을 때도 마찬가지입니다. 오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면, 한곳으로 합치는 편이 작업하기에 훨씬 편합니다.

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

리팩터링하면 코드를 읽고 이해하는 것을 코드에 옮겨 담을 수 있습니다. 이후 테스트 코드를 돌려보면서 머리로 이해한 것이 맞는지 확인할 수 있습니다.

### 쓰레기 줍기 리팩터링

코드 파악 중에 비효율적으로 처리하는 모습을 발견할 수도 있습니다. 하지만 원래 하려던 작업과 관련 없는 일에 몰두할 시간은 충분치 않습니다. 이때, 당장 수정할 수 있는 것만 손대고, 시간이 걸리는 것들은 짧은 메모만 남긴 뒤 원래 작업을 끝내고 처리합니다. 이것을 쓰레기 줍기 리팩터링이라고 합니다.

캠핑 규칙이 제안하듯, 항상 처음 봤을 때보다 깔끔하게 정리합시다. 코드를 훑어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결될 것입니다.

### 계획된 리팩터링과 수시로 하는 리팩터링

리팩터링은 프로그래밍과 구분되는 별개의 활동이 아닙니다. 마치 프로그래밍할 때 if 문 작성 시간을 따로 구분하지 않는 것과 같습니다.

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

보기 싫은 코드를 보면 리팩터링해야 함은 당연하지만, 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 합니다.

> 무언가를 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다.) 그런 다음 쉽게 수정하자.

소프트에어는 새 기능이 필요할 때마다 이를 반영하기 위해 수정됩니다. 이때 새로 작성해 넣은 코드보다 기존 코드의 수정량이 큰 경우가 대체로 많습니다.

그렇다고 해서 계획된 리팩토링이 나쁜 것은 아닙니다. 그동안 리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있습니다. 하지만 이런 이유로 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 한다고 저자는 말합니다. 리팩터링은 대부분은 드러나지 않게, 기회가 될 때마다 해야 합니다.

기능 추가 커밋과 리팩터링 커심을 분리할지 분리하지 않을지는 실험을 통해 팀에 적합한 방식을 찾아야 한다고 말합니다.

### 오래 걸릴는 리팩터링

저자는 팀원 전체가 오래 걸리는 리팩터링에 달려들기 보다 누구든지 관련 작업을 할 때마다 원하는 방향으로 조금씩 개선하는 것이 효과적이라 합니다. 예컨대 의존성을 역전시켜 기존 코드가 인터페이스를 호출하도록 만들고 라이브러리를 쉽게 교체하는 것입니다.

### 코드 리뷰에 리팩터링 활용하기

흔한 PR에서는 코드 리뷰에 리팩터링을 접목하기 어렵습니다. 맥락과 의도를 알지 못하기 때문입니다. 가장 좋은 방식은 나란히 않아저 코드를 훑어가면서 짝 프로그래밍을 통해 리팩터링하는 것이라 합니다.

### 관리자에게는 뭐라고 말해야 할까?

프로 개발자의 역할을 효과적인 소프트웨어를 빠르게 만드는 것입니다. 새로운 기능을 추가하는 데 현재 설계가 적합하지 않다면 먼저 리팩터링하고 나서 함수를 추가하는 편이 빠릅니다. 리팩터링과 생산성의 상관관계에 대해 관리자가 이해하지 못한다면 "리팩터링한다고 말하지 말라"라고 저자는 말합니다.

### 리팩터링하지 말아야 할 때

리팩터링은 내부 동작을 이해해야 할 시점에 해야 효과를 제대로 볼 수 있습니다. 처음부터 새로 작성하는게 쉬울 때도 저자는 리팩터링하지 않는 다고 합니다.

## 2.5 리팩터링 시 고려할 문제

### 새 기능 개발 속도 저하

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

저자는 새 기능을 구현해넣기 편해지겠다 싶은 리팩터링이라면 주저하지 않는다고 합니다. 그리 불편하지 않다면 하지 않고, 어떻게 개선해야할지 떠오르지 않으면 미루기도 한다고 합니다.

리팩터링 할지 말지를 판단하는 능력은 수년에 걸친 경험을 통해 서서히 형성됩니다. 리더는 경험이 부족한 이들이 이런 능력을 빠르게 갖추도록 개발 과정에서 많이 이끌어줘야 합니다.

리팩터링은 오직 경제적인 이유로 행해야 합니다. 개발 시간 단축, 쉬운 기능 추가, 디버그 시간 단축에 목표가 있는 것이지 클린 코드에 목적이 있지 않습니다.

### 코드 소유권

함수를 외부의 다른 팀이 호출하고 있다면 형태를 쉽게 변경할 수 없습니다. 이럴 때는 기존 함수를 유지하고 내부에서 새로운 함수를 호출하도록 수정할 수 있습니다. 조금 복잡해지는 것은 감수해야 합니다.

저자의 방식은 코드의 소유권은 팀에 두어 누구든지 수정 가능하게 만드는 것입니다. 각자 책임지는 도메인이 존재는 하겠지만 그것은 **자신이 맡은 영역의 변경 사항을 관리하는 것**이지, 다른 사람이 수정하지 못하게 막으라는 뜻이 될 수는 없다고 합니다.

### 브랜치

기능별 브랜치들이 독립적으로 개발되는 기간이 길어질수록 머지는 기하급수적으로 복잡해집니다. 

저자는 지속적 통합(CI)을 이야기합니다. 모든 팀원이 하루에 최소 한 번은 마스터와 통합하여 머지의 복잡도를 낮춰야 한다고 합니다. 이를 위해서는 거대한 기능을 잘게 쪼개는 방법을 배우고, 각 기능을 끄고 킬 수 있는 토글을 통해 완료되지 않은 기능이 시스템 전체를 망가트리지 않도록 해야합니다.

짧은 주기로 통합하며 충돌을 필하고 더 쉽게 리팩토링 할 수 있습니다.

### 테스팅

테스트 코드는 리팩터링 뿐만 아니라 새로운 기능 추가도 안전하게 할 수 있습니다. 버그라는 불안감을 해소하기도 좋습니다.

### 레거시 코드

레거시 코드를 파악할 때 리팩터링이 굉장히 도움됩니다. (저자의 의견에 동의합니다.) 하지만 이러한 희망찬 스토리에 테스트가 없다는 사실이 찬물을 끼얹는 떄가 많습니다. **(저자의 의견에 전적으로 동의합니다.)**

이 문제의 정답은 당연히 테스트 보강입니다. 보통은 테스트를 염두에 두고 설계한 시스템만 쉽게 테스트할 수 있습니다. **(동의)**

하나씩 캠핑 규칙에 따라 처음 왔을 때보다 깨끗하게 치워나가고, 레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링합니다. 코드를 훑게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 떄 얻는 효과도 그만큼 크다는 뜻이니 당연히 이렇게 해야 합니다.

### 데이터베이스

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

우리는 소프트웨어를 실제로 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를 알게 되는 경우가 허다합니다.

YAGNI(you aren't going to need it). 앞으로 필요할 것 같아서 미리 구현해둔 기능 상당수가 전혀 쓰이지 않거나, 미래의 요구사항을 반영하지 못해 오히려 수정하기 어려운 경우가 허다합니다.

리팩터링으로는 변경하기 어려워 미리 생각해두면 시간이 절약되는 경우도 있지만 나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 더 나을 수 있다고 저자는 말합니다.

## 2.7 리팩터링과 소프트웨어 개발 프로세스

리팩터링의 첫 토대는 자가 테스트 코드입니다. 여기에 지속적 통합을 적용하면 리팩터링의 결과가 다른 팀원의 작업에 문제를 일으키면 즉시 알아낼 수 있습니다.

## 2.8 리팩터링과 성능

직관적 설계 vs. 성능은 중요한 주제입니다. 리팩터링으로 인해 소프트웨어가 느려질 수는 있습니다. 하지만 동시에 성능을 튜닝하기는 더 쉬워집니다.

대부분의 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비합니다. 저자는 성능 최적화에 돌입하기 전까지는 코드를 다루기 쉽게 만들고 성능 최적화 단계에서 다음의 단계를 거친다고 합니다.

- 프로파일러를 통해 시간과 공간을 많이 잡아먹는 지점 파악
- 성능에 큰 영향을 주는 작은 부분들을 개선
- 작은 단계로 나눠 진행하며 각 단계마다 컴파일, 테스트, 프로파일링 진행

프로그램을 잘 리팩터링해두면 성능 튜닝에 투입할 시간을 줄일 수 있습니다. 또한, 성능을 더 세밀하게 분석하여 튜닝하기 쉬워집니다.

단기적으로 보면 리팩터링으로 성능이 느려질 수 있지만, 최적화 단계에서 코드를 튜닝하기 훨씬 쉬워지기 때문에 결국 더 빠른 소프트웨어를 얻게 됩니다.

