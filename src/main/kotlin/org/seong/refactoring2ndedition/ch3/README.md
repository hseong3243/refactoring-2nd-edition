## 3. 코드에서 나는 악취

### 3.1 기이한 이름

코드는 단순하고 명료하게 작성해야 합니다. 이를 위한 가장 중요한 요소 하나는 '이름'입니다. 이름만 잘 지어도 문맥을 파악하는 데 드는 고생을 덜 수 있습니다.

**마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높습니다.**


### 3.2 중복 코드

똑같은 코드가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있습니다. 코드가 중복된다면 서로 차이점은 없는지 살펴봐야합니다. 그 중 하나를 변경할 때는 다른 비슷한 코드 모두 살펴보고 적절히 수정해야 합니다.

### 3.3 긴 함수

코드를 이해하고, 고유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나옵니다. 예전에는 함수 호출도 비용이었으나 요즘 언어는 함수 호출 비용이 거의 없다고 합니다. 

저자는 주석을 달아야 할 만한 부분은 무조건 함수로 만든다고 합니다. 함수 본문에는 주석으로 설명하려던 코드가 담기고, 이름은 의도를 드러나게 짓습니다. 함수로 묶는 코드는 한 줄일 수도, 여러 줄일 수도 있지만 핵심은 이름을 통해 의도를 드러내는 것입니다.

저 또한 실무를 하면서 하나의 함수 안에 수십 줄로 구성된 코드를 주석을 통해 의미상으로 구분하는 것을 보았습니다. 그런 것들이 있으면 인텔리제이의 기능을 활용해 메서드로 추출하고 주석을 메서드의 이름으로 사용해보고 있습니다.

### 3.4 긴 매개변수 목록

종종 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있습니다.

클래스는 매개변수 목록을 줄이는 데 효과적인 수단이기도 합니다.

### 3.5 전역 데이터

전역 데이터는 다루기 까다롭습니다. 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생합니다.

### 3.6 가변 데이터

데이터 변경으로 인해 사이드 이펙트가 발생할 수 있습니다. 이러한 사이드 이펙트가 매우 드물게 발생한다면 찾아내기 쉽지 않습니다.

### 3.7 뒤엉킨 변경

뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 나타납니다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생합니다.

### 3.8 산탄총 수술(Shotgun Surgery)

산탄총 수술은 냄새나는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍깁니다. 변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽습니다.

### 3.9 기능 편애

프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력합니다. 

기능 편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새입니다. 이를 해결하려면 가장 많은 데이터를 포함하는 모듈로 옮기면 됩니다.

디자인패턴 중에는 이를 거스르는 것도 있는데 전략 패턴과 비지터 패턴입니다.

> 자기 스스로 기능을 가진것이 아니라 자기와 연결된 외부 오브젝트의 기능을 사용하는 비중이 너무 큰 코드들. 클래스가 자신의 로직은 없고 다른 오브젝트에 있는 기능들을 계속 호출하는 방식으로 쌓인 것들.
> 이런 경우에는 해당 오브젝트 안에서 한번에 처리하고 결과를 받도록 하는게 좋을 것이다.
> 전략 패턴이나 비지터를 예외적으로 언급한 이유는 전랴과 비지터는 그 자체로 오브젝트이다. 이런 것들을 일부러 데이터와 연산을 분리시킨것이다. 전략은 어떤 연산을 계속해서 교환해서 사용하도록 하는 것이다. 이를 통해 다양한 전략으로 동적인 설계를 가질 수가 있다.
> 비지터는 실전에서 쓰는 경우 잘 못봤다. 가장 전형적인 이유는 더블 디스패치가 필요할 때. 유명한 글이 하나 있다. 우리가 쓰는 언어는 싱글 디스패치. 다형성이 양방향으로 적용되는 케이스가 필요할 때 있는데 비지터 패턴을 이용해서 구현할 수 있다.


### 3.10 데이터 뭉치

여러 데이터가 항상 함께 뭉쳐 다니는 모습을 흔히 목결할 수 있습니다. 이런 것들은 클래스로 추출하고 객체를 통째로 넘기면서 매개변수 수를 줄여볼 수 있습니다.

데이터 뭉치인지 판별하라면 값 하나를 삭제해서 구분할 수 있습니다. 나머지 데이터가 의미가 없다면 클래스로 뭉칠 수 있는 데이터입니다. 클래스로 뭉쳤다면, 그 클래스로 옮길 수 있는 좋은 동작은 없는지 살펴볼 수 있습니다. 그럼 곧 유용한 클래스가 만들어 질 수 있습니다.

### 3.11 기본형 집착

대부분의 언어는 다양한 기본형을 제공합니다. 하지만 화폐, 좌표 등을 기본형으로 다루기는 적절하지 않습니다. 이런 데이터를 다루기 위한 자료형을 정의해서 의미 있는 방식으로 사용할 수 있습니다.

### 3.12 반복되는 switch문

중복된 switch문이 문제가 되는 이유는 조건절을 하나 추할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문입니다. 다형성은 반복된 switch문이 내뿐는 사악한 기운을 제압하여 코드베이스를 최신 스타일로 바꿔주는 세련된 무기입니다.

### 3.13 반복문

반복문은 filter나 map 같은 파이프라인 연산을 통해서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있습니다.

### 3.14 성의 없는 요소(Lazy Element)

필요없는 프로그램 요소가 있다면 함수, 클래스 인라인하기, 계층 합치기를 통해서 제거하는게 더 나을 수 있습니다.

### 3.15 추측성 일반화(Speculative Generality)

이는 '나중에 필요할 거야'라는 생각으로 당장 필요 없는 모든 종류의 후킹(hooking) 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍깁니다. 그 결과는 이해허가나 관리하기 어려워진 코드입니다.

하는 일이 없는 추상 클래스는 계층 합치기, 함수, 클래스 인라인하기로 삭제합니다. 추측성 일반화는 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼 수 있습니다.

### 3.16 임시 필드

특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있습니다. 하지만 객체를 가져올 때는 모든 필드가 채워져 있으리라 기대하는 게 보통입니다. 이런 임시 필드를 가진 코드는 이해하기 어렵습니다.

### 3.17 메시지 체인

메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 시긍로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말합니다. 예를 들면 `getxxx().getxxx()` 같은 메서드 체이닝을 말합니다.

> member.getRole.hasPermission(ADMIN) 롤이 굉장히 다양하고 동적으로 추가될수있다면 롤을 꺼내와서 롤에 대해 여러가지 작업을 수행할 수도 있을것이다. member.isAdmin() 처럼 많이 사용하는 경우라면 굳이 롤을 꺼내서 쓰는것보다 메서드 만드는게 더 좋을것이라 생각한다.

### 3.18 중개자

클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임한다면 중개를 제거하여 실제로 일을 하는 객체와 직접 소통하게 해야 합니다.

### 3.19 내부자 거래

여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제 3의 모듈을 만들거나 `위임 숨기기`를 이용하여 다른 모듈이 중간자 역할을 하게 만듭니다.

### 3.20 거대한 클래스

클래스에 필드가 많으면 중복 코드가 생기기 쉽습니다. 이럴 때는 `클래스 추출하기`로 필드 일부를 따로 묶을 수 있습니다.

추출할 때는 가까이 있는게 합당해보이는 필드들, 가령 접두사나 접미어가 같은 필드들이 있습니다.

필드와 마찬가지로 코드량이 많은 클래스도 내부에서 중복을 해결할 수 있을지 모릅니다.

### 3.21 서로 다른 인터페이스의 대안 클래스들

메서드 시그니처를 일치시켜 서로 교체 가능하도록 만들수 있습니다. `함수 선언 바꾸기`만으로 부족하다면 `함수 옮기기`를 이용하여 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣을 수 있습니다. 그러다 중복 코드가 생기면 대안 클래스들간에 `슈퍼클래스 추출하기`를 적용할지 고려해볼 수 있습니다.

### 3.22 데이터 클래스

데이터 클래스란 데이터 필드와 게터/세터로만 구성된 클래스를 말합니다. 

변경하면 안 되는 필드는 접근을 차단하고, 캡슐화를 통해 외부의 접근을 봉쇄해야 합니다.

대표적인 예시가 1장의 중간 데이터 구조입니다. 이러한 클래스는 불변이어야 합니다. 불변 데이터로부터 나오는 정보는 게터를 통하지 않고 그냥 필드 자체를 공개해도 됩니다.

### 3.23 상속 포기

서브 클래스가 슈퍼 클래스의 유산을 원치 않는다면 어떻게 해야할까요?

상속 포기는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 심하게 나는 냄새입니다. 

### 3.24 주석

주석은 악취가 아닌 향기를 입힙니다. 그러나 장황한 주석은 코드를 잘못 작성했기 때문인 경우가 많습니다.

특정 코드 블록이 하는 일에 주석을 남기고 싶다면 `함수 추출하기`를 적용해봅니다. 이미 추출된 함수에 여전히 설명이 필요하다면 `함수 선언 바꾸기`로 함수 이름을 바꿔봅니다. 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 `asserttion` 추가하기가 있습니다.

> 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.

무엇을 할지 모를때라면 주석을 달아두면 좋습니다. 코드를 지금처럼 작성한 이유를 설명할수도 있습니다. 이는 나중에 코드를 수정해야 할 프로그래머에게 유용한 정보가 됩니다.

-> 긴 함수 쪼갤때 기준중 하나가 조건문, 스위치, 루프가 있다. 사실 잘 안하긴하는데 분리하면 좋긴 할 것이다. 일단 루프를 들어내는 것부터 하는 것이 좋지 않나. 보통 루프 들어가면 그 안에서 하는 일이 많아지는데 습관적으로 분리하고 뭘하는지 잘 기술하는게 좋지 않나 생각한다.


> 추상화 레벨이 서로 다르면 이해하기 어려워질 수 있다. 이메일이 올바른가 체크했다가, 토탈을 계산하기 위해 각 상품 가격을 끌어왔다가, 주문을 했다가 하면 들쑥날쑨한 추상화 레벨로 인해 이해하기 어렵다.
> 
> 도메인 오브젝트의 로직이 외부의 작업에 의존하는경우가 분명 있다. 그런거는 도메인 서비스로 만들면 된다. 도메인 서비스자체는 도메인 레이어에서 인터페이스로 만들어져야 하고 구현은 스프링 빈이라면 얼마든지 리포지토리, 외부 api 호출을 얼마든지 할 수 있을 것이다. 어떤 경우에는 도메인 서비스가 가진 메서드에 엔티티를 집어 넣는게 더 좋은 경우도 있다.
> 외부에 정책이라든가를 이용해서 하면 서비스에 밀어넣어야 할 것이다.
> 
> 애플리케이션 서비스는 일종의 퍼사드 역할을 한다. 뒤에 있는 여러가지를 호출해서 하나의 큰 로직을 수행한다. 복잡한 로직은 잘 안들어간다.
> 도메인 서비스는 하나의 엔티티 안에는 넣기 애매한 로직들. 엔티티가 너무 방대해지거나 긴밀하지만 분리하는게 좋을 때. 상태를 가지지 않는 서비스 형태로.
> 테크니컬 서비스는 인프라 레이어에 들어있는 것들. 이메일, 데이터베이스를 처리하는.
